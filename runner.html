<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Runner</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f7f7f7;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            border: 1px solid #535353;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <script>
        // Game state management
        const GameState = {
            START: 'start',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver'
        };

        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.state = GameState.START;
                this.score = 0;
                this.highScore = this.getHighScore();
                this.gameSpeed = 6;
                this.obstacleTimer = 0;
                this.animationFrame = 0;
                this.dayNightCycle = 0;
                this.runner = new Runner(50, 300);
                this.sky = new Sky(canvas);
                this.obstacles = [];
                this.buildings = [];
                this.initBuildings();
                this.powerUpActive = false;
                this.powerUpTimer = 0;
                this.ground = { y: 350, height: 50, color: '#535353' };

                this.powerUp = null;
                this.businessModeActive = false;
                this.businessModeTimer = 0;
                this.businessModeDuration = 300; // 5 seconds at 60 fps

                this.difficultyTimer = 0;
                this.obstacleGap = 0;

                this.sounds = {
                    jump: new Audio('http://codeskulptor-demos.commondatastorage.googleapis.com/pang/pop.mp3'),
                    powerUp: new Audio('http://codeskulptor-demos.commondatastorage.googleapis.com/GalaxyInvaders/bonus.wav'),
                    crash: new Audio('http://codeskulptor-demos.commondatastorage.googleapis.com/descent/Crumble%20Sound.mp3'),
                    gameOver: new Audio('http://commondatastorage.googleapis.com/codeskulptor-assets/Collision8-Bit.ogg')
                };

                this.particles = [];

                // New Features
                this.speedBoostActive = false;
                this.speedBoostTimer = 0;
                this.speedBoostDuration = 300; // 5 seconds at 60 fps
            }

            getHighScore() {
                return parseInt(localStorage.getItem('highScore')) || 0;
            }

            setHighScore(score) {
                localStorage.setItem('highScore', score);
            }

            initBuildings() {
                const buildingCount = Math.ceil(this.canvas.width / 150) + 1;
                for (let i = 0; i < buildingCount; i++) {
                    this.buildings.push(new Building(i * 150, this.canvas.height));
                }
            }

            update() {
                if (this.state !== GameState.PLAYING) return;

                this.runner.update();
                this.updateObstacles();
                this.buildings.forEach(building => {
                    building.update(this.gameSpeed, this.canvas.width, this.canvas.height);
                });
                this.sky.update(this.gameSpeed);
                
                this.score++; 
                if (this.speedBoostActive) this.score++;
                if (this.score % 500 === 0) {
                    this.gameSpeed += 0.5;
                }

                this.obstacleTimer++;
                if (!this.obstacleGap)
                    this.obstacleGap = Math.random() * 40 + 20;

                if (this.obstacleTimer > this.obstacleGap) {
                    this.obstacleTimer = 0;
                    this.obstacleGap = 0;
                    if (this.obstacles.length === 0 || this.obstacles[this.obstacles.length - 1].x < this.canvas.width - 250) {
                        this.generateObstacle();
                    }
                }

                // Update power-up
                if (!this.powerUp && Math.random() < 0.002) {
                    this.generatePowerUp();
                }
                if (this.powerUp) {
                    this.powerUp.update(this.gameSpeed);
                    if (this.powerUp.x + this.powerUp.width < 0) {
                        this.powerUp = null;
                    }
                }

                // Check for power-up collection
                if (this.powerUp && this.checkPowerUpCollision()) {
                    if (this.powerUp.type === 'business') {
                        game.activateBusinessMode();
                    } else if (this.powerUp.type === 'speed') {
                        game.activateSpeedBoost();
                    }

                    this.powerUp = null;
                    this.sounds.powerUp.play();
                    this.createParticles(this.runner.x, this.runner.y);
                }

                // Update Business Mode
                if (this.businessModeActive) {
                    this.businessModeTimer++;
                    if (this.businessModeTimer >= this.businessModeDuration) {
                        this.deactivateBusinessMode();
                    }
                }

                if (this.checkObstacleCollision()) {
                    this.endGame();
                }

                // Update particles
                this.particles = this.particles.filter(particle => particle.lifespan > 0);
                this.particles.forEach(particle => particle.update());

                this.animationFrame = (this.animationFrame + 1) % 20;
                this.dayNightCycle = (this.dayNightCycle + 0.0005) % 1;

                // Update speed boost
                if (this.speedBoostActive) {
                    this.speedBoostTimer++;
                    if (this.speedBoostTimer >= this.speedBoostDuration) {
                        this.deactivateSpeedBoost();
                    }
                }
            }

            createParticles(x, y) {
                for (let i = 0; i < 20; i++) {
                    this.particles.push(new Particle(x, y));
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.sky.draw(this.ctx);
                this.buildings.forEach(building => building.draw(this.ctx, this.dayNightCycle));
                this.drawGround();
                this.obstacles.forEach(obstacle => obstacle.draw(this.ctx));

                if (this.powerUp) {
                    this.powerUp.draw(this.ctx);
                }
                this.runner.draw(this.ctx);

                this.drawScore();

                // Draw particles
                this.particles.forEach(particle => particle.draw(this.ctx));

                if (this.state === GameState.START) {
                    this.drawStartScreen();
                } else if (this.state === GameState.GAME_OVER) {
                    this.drawGameOverScreen();
                } else if (this.state === GameState.PAUSED) {
                    this.drawPausedScreen();
                }
            }

            generatePowerUp() {
                this.powerUp = new PowerUp(this.canvas.width, 300);
            }

            activateBusinessMode() {
                this.businessModeActive = true;
                this.businessModeTimer = 0;
                this.runner.activateBusinessMode();
            }

            deactivateBusinessMode() {
                this.businessModeActive = false;
                this.runner.deactivateBusinessMode();
            }

            drawGround() {
                this.ctx.fillStyle = this.ground.color;
                this.ctx.fillRect(0, this.ground.y, this.canvas.width, this.ground.height);

                this.ctx.fillStyle = '#A9A9A9';
                this.ctx.fillRect(0, this.ground.y, this.canvas.width, 20);

                this.ctx.strokeStyle = '#FFFFFF';
                this.ctx.lineWidth = 2;
                for (let i = 0; i < this.canvas.width; i += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, this.ground.y);
                    this.ctx.lineTo(i + 30, this.ground.y);
                    this.ctx.stroke();
                }
            }

            generateObstacle() {
                const obstacleTypes = [
                    { width: 30, height: 50, y: this.ground.y - 50, color: '#FF0000', type: 'hydrant' },
                    { width: 60, height: 70, y: this.ground.y - 70, color: '#000000', type: 'house' },
                    { width: 50, height: 30, y: this.ground.y - 30, color: '#000000', type: 'car' },
                    { width: 40, height: 20, y: this.ground.y - Math.random() * 100 - 40, color: '#303030', type: 'drone' },
                    { width: 60, height: 15, y: this.ground.y, color: '#000000', type: 'hole' }
                ];
                const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                const randomSpacing = Math.random() * 0; // Random spacing between 0 and 100
                this.obstacles.push(new Obstacle(this.canvas.width + randomSpacing, type.y, type.width, type.height, type.color, type.type));
            }

            updateObstacles() {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    this.obstacles[i].update(this.gameSpeed);
                    if (this.obstacles[i].x + this.obstacles[i].width < 0) {
                        this.obstacles.splice(i, 1);
                    }
                }
            }

            drawScore() {
                // this.ctx.fillStyle = 'black';
                // this.ctx.font = '20px Arial';
                // this.ctx.fillText(`Score: ${this.score}`, 10, 30);
                // this.ctx.fillText(`High Score: ${this.highScore}`, 10, 60);

                // Set the font and size
                this.ctx.font = '22px "Press Start 2P", monospace';

                // Calculate the width of the score text
                const scoreWidth = this.ctx.measureText(`Score: ${this.score}`).width;
                const highScoreWidth = this.ctx.measureText(`High Score: ${this.highScore}`).width;

                // Create a linear gradient for the score
                const scoreGradient = this.ctx.createLinearGradient(0, 0, scoreWidth + 20, 0);
                scoreGradient.addColorStop(0, '#FFD700');
                scoreGradient.addColorStop(0.5, '#FFA500');
                scoreGradient.addColorStop(1, '#FF4500');

                // Create a linear gradient for the high score
                const highScoreGradient = this.ctx.createLinearGradient(0, 0, highScoreWidth + 20, 0);
                highScoreGradient.addColorStop(0, '#FFD700');
                highScoreGradient.addColorStop(0.5, '#FFA500');
                highScoreGradient.addColorStop(1, '#FF4500');

                // // Draw the score and high score with a semi-transparent background
                // this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                // this.ctx.fillRect(10, 10, scoreWidth + 20, 40);
                // this.ctx.fillRect(10, 50, highScoreWidth + 20, 40);

                // Set the gradient as the fill style for the score and high score text
                this.ctx.textAlign = 'left';
                this.ctx.fillStyle = scoreGradient;
                this.ctx.fillText(`Score: ${this.score}`, 20, 35);
                this.ctx.fillStyle = highScoreGradient;
                this.ctx.fillText(`High Score: ${this.highScore}`, 20, 75);
            }

            drawStartScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // this.ctx.fillStyle = 'white';
                // this.ctx.font = '40px Arial';
                // this.ctx.fillText('City Runner', 310, 180);
                // this.ctx.font = '20px Arial';
                // this.ctx.fillText('Press SPACE to start', 310, 220);

                // Use a retro-inspired font
                this.ctx.font = '60px "VT323", monospace';
                this.ctx.fillStyle = 'white';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('City Runner', this.canvas.width / 2, 250);

                this.ctx.font = '18px "VT323", monospace';
                this.ctx.fillText('Press SPACE to start', this.canvas.width / 2, 300);
            }

            drawGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.font = '50px "VT323", monospace';
                this.ctx.fillStyle = 'white';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Game Over!', this.canvas.width / 2, 190);

                this.ctx.font = '36px "VT323", monospace';
                this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, 250);
                this.ctx.fillText(`High Score: ${this.highScore}`, this.canvas.width / 2, 290);

                this.ctx.font = '18px "VT323", monospace';
                this.ctx.fillText('Press SPACE to restart', this.canvas.width / 2, 350);
            }

            drawPausedScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.font = '50px "VT323", monospace';
                this.ctx.fillStyle = 'white';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Paused', this.canvas.width / 2, 250);

                this.ctx.font = '18px "VT323", monospace';
                this.ctx.fillText('Press P to resume', this.canvas.width / 2, 300);
            }

            startGame() {
                this.state = GameState.PLAYING;
                this.score = 0;
                this.gameSpeed = 6;
                this.obstacles = [];
                this.runner.reset();
                this.obstacleTimer = 0;
            }

            pauseGame() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                } else if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                }
            }

            endGame() {
                this.state = GameState.GAME_OVER;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.setHighScore(this.highScore);
                }
                this.sounds.gameOver.play();
            }

            restart() {
                this.buildings = [];
                this.initBuildings();
            }

            checkPowerUpCollision() {
                if (!this.powerUp) return false;

                const runnerHitbox = {
                    x: this.runner.x + 5,
                    y: this.runner.y + (this.runner.isDucking ? 40 : 0),
                    width: this.runner.width - 10,
                    height: this.runner.isDucking ? this.runner.duckHeight : this.runner.height
                };

                return this.checkCollision(runnerHitbox, this.powerUp);
            }

            checkObstacleCollision() {
                return this.obstacles.some(obstacle => {
                    const runnerHitbox = {
                        x: this.runner.x + 5,
                        y: this.runner.y + (this.runner.isDucking ? 40 : 0),
                        width: this.runner.width - 10,
                        height: this.runner.isDucking ? this.runner.duckHeight : this.runner.height
                    };

                    if (this.checkCollision(runnerHitbox, obstacle)) {
                        if (this.businessModeActive) {
                            this.sounds.crash.play();

                            // Destroy obstacle and add bonus points
                            this.score += 100;
                            this.obstacles = this.obstacles.filter(obs => obs !== obstacle);
                            return false;
                        }
                        return true;
                    }
                    return false;
                });
            }

            checkCollision(object1, object2) {
                return object1.x < object2.x + object2.width &&
                    object1.x + object1.width > object2.x &&
                    object1.y < object2.y + object2.height &&
                    object1.y + object1.height > object2.y;
            }
        
            generatePowerUp() {
                const powerUpTypes = ['business', 'speed'];
                const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                const y = 150 + Math.random() * 150;
                this.powerUp = new PowerUp(this.canvas.width, y, type);
            }

            activateSpeedBoost() {
                this.speedBoostActive = true;
                this.speedBoostTimer = 0;
                this.gameSpeed ++;
                this.runner.activateSpeedBoost();
            }

            deactivateSpeedBoost() {
                this.speedBoostActive = false;
                this.gameSpeed --;
                this.runner.deactivateSpeedBoost();
            }
        }

        class Runner {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 60;
                this.duckHeight = 30;
                this.isJumping = false;
                this.isDucking = false;
                this.jumpVelocity = 0;
                this.gravity = 1.0;
                this.animationFrame = 0;

                this.isBusinessMode = false;
                this.isSpeedBoost = false;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(20, 55, 20, 5, 0, 0, 2 * Math.PI);
                ctx.fill();

                // Body
                if (this.isSpeedBoost && this.isBusinessMode) {
                    this.drawBusinessFlash(ctx);
                } else if (this.isSpeedBoost) {
                    this.drawFlash(ctx);
                } else if (this.isBusinessMode) {
                    this.drawBusinessMonkey(ctx);
                } else if (this.isDucking) {
                    this.drawDuckingMonkey(ctx);
                } else if (this.isJumping) {
                    this.drawJumpingMonkey(ctx);
                } else {
                    this.drawRunningMonkey(ctx);
                }

                ctx.restore();
            }

            drawRunningMonkey(ctx) {
                const legOffset = Math.sin(this.animationFrame * 0.5) * 5;

                // Body
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(10, 20, 30, 30);

                // Head
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(10, 0, 25, 20);

                // Face
                ctx.fillStyle = '#FFA07A';
                ctx.fillRect(15, 5, 15, 15);

                // Eyes
                ctx.fillStyle = 'black';
                ctx.fillRect(18, 8, 4, 4);
                ctx.fillRect(28, 8, 4, 4);

                // Mouth
                ctx.fillStyle = 'black';
                ctx.fillRect(23, 15, 6, 2);

                // Arms
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(5, 25, 5, 15 + legOffset);
                ctx.fillRect(35, 25, 5, 15 - legOffset);

                // Legs
                ctx.fillRect(15, 50, 5, 10 + legOffset);
                ctx.fillRect(30, 50, 5, 10 - legOffset);

                // Briefcase
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(35, 40, 15, 20);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(38, 45, 5, 2);
            }

            drawJumpingMonkey(ctx) {
                // Similar to running monkey, but with raised arms and legs tucked
                // Body
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(10, 20, 30, 30);

                // Head
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(10, 0, 25, 20);

                // Face
                ctx.fillStyle = '#FFA07A';
                ctx.fillRect(15, 5, 15, 15);

                // Eyes
                ctx.fillStyle = 'black';
                ctx.fillRect(18, 8, 4, 4);
                ctx.fillRect(28, 8, 4, 4);

                // Mouth
                ctx.fillStyle = 'black';
                ctx.fillRect(23, 15, 6, 2);

                // Arms (raised)
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(5, 10, 5, 20);
                ctx.fillRect(35, 10, 5, 20);

                // Legs (tucked)
                ctx.fillRect(15, 40, 5, 15);
                ctx.fillRect(30, 40, 5, 15);

                // Briefcase (held higher)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(35, 25, 15, 20);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(38, 30, 5, 2);
            }

            drawDuckingMonkey(ctx) {
                // Squashed monkey
                // Body
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(10, 30, 30, 20);

                // Head (lowered)
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(10, 20, 25, 15);

                // Face
                ctx.fillStyle = '#FFA07A';
                ctx.fillRect(15, 22, 15, 12);

                // Eyes
                ctx.fillStyle = 'black';
                ctx.fillRect(18, 25, 4, 3);
                ctx.fillRect(28, 25, 4, 3);

                // Mouth
                ctx.fillStyle = 'black';
                ctx.fillRect(23, 30, 6, 2);

                // Arms
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(5, 35, 5, 10);
                ctx.fillRect(35, 35, 5, 10);

                // Legs
                ctx.fillRect(15, 50, 5, 5);
                ctx.fillRect(30, 50, 5, 5);

                // Briefcase (on the ground)
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(40, 40, 15, 20);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(43, 45, 5, 2);
            }

            drawBusinessMonkey(ctx) {
                // Body (navy suit)
                ctx.fillStyle = '#000080';
                ctx.fillRect(10, 20, 30, 30);

                // Head
                ctx.fillStyle = '#C68E17';
                ctx.fillRect(10, 0, 25, 20);

                // Face
                ctx.fillStyle = '#FFA07A';
                ctx.fillRect(15, 5, 15, 15);

                // Eyes
                ctx.fillStyle = 'black';
                ctx.fillRect(18, 8, 4, 4);
                ctx.fillRect(28, 8, 4, 4);

                // Mouth
                ctx.fillStyle = 'black';
                ctx.fillRect(23, 15, 6, 2);

                // Arms
                ctx.fillStyle = '#000080';
                ctx.fillRect(5, 25, 5, 15);
                ctx.fillRect(35, 25, 5, 15);

                // Legs
                ctx.fillRect(15, 50, 5, 10);
                ctx.fillRect(30, 50, 5, 10);

                // Tie
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(25, 20);
                ctx.lineTo(30, 30);
                ctx.lineTo(25, 40);
                ctx.lineTo(20, 30);
                ctx.closePath();
                ctx.fill();

                // Briefcase
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(35, 40, 15, 20);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(38, 45, 5, 2);

                // Glow effect
                const gradient = ctx.createRadialGradient(45, 52.5, 0, 45, 52.5, 20);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(25, 30, 40, 45);
            }

            drawFlash(ctx) {
                const legOffset = Math.sin(this.animationFrame * 0.5) * 5;
                const effectOffset = (this.animationFrame % 20) / 20; // Creates a cyclical effect

                // Body (red like The Flash)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(10, 20, 30, 30);
                
                // Flash mask (yellow)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(10, 0, 25, 6);  // Top of mask
                ctx.fillRect(10, 0, 5, 20);  // Left side of mask
                ctx.fillRect(30, 0, 5, 20);  // Right side of mask

                // Face
                ctx.fillStyle = '#FFA07A';
                ctx.fillRect(15, 5, 15, 15);

                // Eyes (white with black pupils)
                ctx.fillStyle = 'white';
                ctx.fillRect(18, 8, 4, 4);
                ctx.fillRect(28, 8, 4, 4);
                ctx.fillStyle = 'black';
                ctx.fillRect(19, 9, 2, 2);
                ctx.fillRect(29, 9, 2, 2);

                // Mouth
                ctx.fillStyle = 'black';
                ctx.fillRect(23, 15, 6, 2);

                // Lightning bolt ear pieces
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(8, 8, 2, 4);
                ctx.fillRect(35, 8, 2, 4);

                // Arms (red)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(5, 25, 5, 15 + legOffset);
                ctx.fillRect(35, 25, 5, 15 - legOffset);

                // Legs (yellow boots)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(15, 50, 5, 10 + legOffset);
                ctx.fillRect(30, 50, 5, 10 - legOffset);

                // Lightning bolt emblem on chest
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(25, 25);
                ctx.lineTo(20, 35);
                ctx.lineTo(25, 35);
                ctx.lineTo(20, 45);
                ctx.lineTo(30, 32);
                ctx.lineTo(25, 32);
                ctx.closePath();
                ctx.fill();

                // Create multiple layers of speed lines
                for (let layer = 0; layer < 3; layer++) {
                    const layerOffset = (effectOffset + layer / 3) % 1; // Stagger the layers

                    // Yellow speed lines
                    ctx.strokeStyle = `rgba(255, 255, 0, ${0.7 - layer * 0.2})`; // Fade out for back layers
                    ctx.lineWidth = 2 - layer * 0.5; // Thinner lines for back layers

                    for (let i = 0; i < 5; i++) {
                        const x = -10 + i * 10 - layerOffset * 20;
                        ctx.beginPath();
                        ctx.moveTo(x + 10, 0);
                        ctx.lineTo(x + 30, 60);
                        ctx.stroke();
                    }
                }
            }

            drawBusinessFlash(ctx) {
                const legOffset = Math.sin(this.animationFrame * 0.5) * 5;
                const effectOffset = (this.animationFrame % 20) / 20; // Creates a cyclical effect

                // Body (navy suit)
                ctx.fillStyle = '#000080';
                ctx.fillRect(10, 20, 30, 30);

                // Head (red like The Flash)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(10, 0, 25, 20);

                // Face (lighter red)
                ctx.fillStyle = '#FF6347';
                ctx.fillRect(15, 5, 15, 15);

                // Eyes (white with black pupils)
                ctx.fillStyle = 'white';
                ctx.fillRect(18, 8, 4, 4);
                ctx.fillRect(28, 8, 4, 4);
                ctx.fillStyle = 'black';
                ctx.fillRect(19, 9, 2, 2);
                ctx.fillRect(29, 9, 2, 2);

                // Mouth
                ctx.fillStyle = 'black';
                ctx.fillRect(23, 15, 6, 2);

                // Tie with Flash emblem
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(25, 20);
                ctx.lineTo(30, 30);
                ctx.lineTo(25, 40);
                ctx.lineTo(20, 30);
                ctx.closePath();
                ctx.fill();

                // Arms
                ctx.fillStyle = '#000080';
                ctx.fillRect(5, 25, 5, 15);
                ctx.fillRect(35, 25, 5, 15);

                // Legs
                ctx.fillRect(15, 50, 5, 10);
                ctx.fillRect(30, 50, 5, 10);

                // Briefcase (glowing)
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(35, 40, 15, 20);
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(38, 45, 5, 2);

                // Lightning bolt emblem on chest
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(25, 25);
                ctx.lineTo(20, 35);
                ctx.lineTo(25, 35);
                ctx.lineTo(20, 45);
                ctx.lineTo(30, 32);
                ctx.lineTo(25, 32);
                ctx.closePath();
                ctx.fill();

                // Create multiple layers of speed lines
                for (let layer = 0; layer < 3; layer++) {
                    const layerOffset = (effectOffset + layer / 3) % 1; // Stagger the layers

                    // Orange speed lines
                    ctx.strokeStyle = `rgba(255, 165, 0, ${0.6 - layer * 0.2})`;
                    ctx.lineWidth = 1.5 - layer * 0.3;

                    for (let i = 0; i < 4; i++) {
                        const x = -5 + i * 12 - layerOffset * 24;
                        ctx.beginPath();
                        ctx.moveTo(x + 12, 10);
                        ctx.lineTo(x + 36, 50);
                        ctx.stroke();
                    }
                }
            }

            activateBusinessMode() {
                this.isBusinessMode = true;
            }

            deactivateBusinessMode() {
                this.isBusinessMode = false;
            }

            drawSpeedBoostEffect(ctx) {
                // Instead of drawing lightning, we'll add a glowing outline to the character
                ctx.save();
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 10;
                
                // Outline the body
                ctx.strokeRect(10, 20, 30, 30);
                
                // Outline the head
                ctx.strokeRect(5, 0, 25, 20);
                
                // Outline the legs
                ctx.strokeRect(15, 50, 5, 10);
                ctx.strokeRect(30, 50, 5, 10);
                
                ctx.restore();
            }

            activateSpeedBoost() {
                this.isSpeedBoost = true;
            }

            deactivateSpeedBoost() {
                this.isSpeedBoost = false;
            }

            update() {
                if (this.isJumping) {
                    this.y += this.jumpVelocity;
                    this.jumpVelocity += this.gravity;

                    if (this.y >= 300) {
                        this.y = 300;
                        this.isJumping = false;
                        this.jumpVelocity = 0;
                    }
                }

                this.animationFrame = (this.animationFrame + 1) % 20;
            }

            jump() {
                if (!this.isJumping) {
                    this.isJumping = true;
                    this.jumpVelocity = -15.5;
                }
            }

            duck() {
                this.isDucking = true;
            }

            stand() {
                this.isDucking = false;
            }

            reset() {
                this.y = 300;
                this.isJumping = false;
                this.isDucking = false;
                this.jumpVelocity = 0;
                this.deactivateBusinessMode();
                this.deactivateSpeedBoost();
            }
        }

        class Obstacle {
            constructor(x, y, width, height, color, type) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.type = type;

                if (this.type === 'car') {
                    this.carColor = this.randomCarColor();
                }

                if (this.type === 'house') {
                    this.houseColor = this.randomHouseColor();
                }

                if (this.type === 'drone') {
                    this.baseY = y;
                    this.angle = 0;
                    this.oscillationSpeed = Math.random() * 0.05 + 0.02; // Variable oscillation speed
                    this.oscillationAmplitude = Math.random() * 20 + 10; // Variable oscillation amplitude
                }
            }

            randomCarColor() {
                const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            randomHouseColor() {
                const colors = ['#8B4513', '#A0522D', '#CD853F', '#DEB887', '#D2691E'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update(gameSpeed) {
                this.x -= gameSpeed;
                if (this.type === 'drone') {
                    this.angle += this.oscillationSpeed;
                    this.y = this.baseY + Math.sin(this.angle) * this.oscillationAmplitude;
                }
            }

            draw(ctx) {
                if (this.type === 'hydrant') {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(this.x + 10, this.y, 10, this.height);
                    ctx.fillRect(this.x, this.y + 10, 30, 10);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.arc(this.x + 15, this.y, 7, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'car') {
                    ctx.fillStyle = this.carColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(this.x + 5, this.y + 20, 15, 15);
                    ctx.fillRect(this.x + this.width - 20, this.y + 20, 15, 15);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(this.x + 5, this.y + 5, 15, 10);
                } else if (this.type === 'house') {
                    ctx.fillStyle = this.houseColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#FFFFFF';
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 2; j++) {
                            ctx.fillRect(this.x + 10 + i * 20, this.y + 10 + j * 20, 10, 10);
                        }
                    }
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(this.x + 25, this.y + 40, 10, 30);
                } else if (this.type === 'drone') {
                    ctx.fillStyle = '#303030';
                    ctx.fillRect(this.x, this.y + 5, this.width, 10);
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(this.x + 5, this.y + 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(this.x + this.width - 5, this.y + 8, 3, 3);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(this.x + 10, this.y, 5, 5);
                    ctx.fillRect(this.x + this.width - 15, this.y, 5, 5);
                    ctx.fillRect(this.x + 10, this.y + 15, 5, 5);
                    ctx.fillRect(this.x + this.width - 15, this.y + 15, 5, 5);
                } else if (this.type === 'hole') {
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width / 2, this.y, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.type = type;
            }

            update(gameSpeed) {
                this.x -= gameSpeed;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                // Draw circular background
                ctx.beginPath();
                ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                ctx.fillStyle = this.type === 'business' ? '#FFD700' : '#FFFFFF';
                ctx.fill();

                // Draw icon
                if (this.type === 'business') {
                    this.drawDollarSign(ctx);
                } else {
                    this.drawFlashLogo(ctx);
                }

                // Add a glow effect
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width / 2);
                gradient.addColorStop(0, this.type === 'business' ? 'rgba(255, 215, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.width, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            drawDollarSign(ctx) {
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', 0, 0);
            }

            drawFlashLogo(ctx) {
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(-8, -10);
                ctx.lineTo(0, -2);
                ctx.lineTo(-4, 2);
                ctx.lineTo(8, 10);
                ctx.lineTo(0, 2);
                ctx.lineTo(4, -2);
                ctx.closePath();
                ctx.fill();
            }
        }

        class Building {
            constructor(x, canvasHeight) {
                this.x = x;
                this.width = Math.random() * 50 + 100; // Random width between 100 and 150
                this.height = Math.random() * 200 + 100; // Random height
                this.y = canvasHeight - this.height; // Start from ground
                this.windows = this.generateWindows();
                this.color = this.randomBuildingColor();
            }

            randomBuildingColor() {
                // const colors = ['#8B4513', '#A0522D', '#CD853F', '#DEB887', '#D2691E'];
                const colors = [
                    '#708090', // Slate gray
                    '#778899', // Light slate gray
                    '#696969', // Dim gray
                    '#808080', // Gray
                    '#A9A9A9', // Dark gray
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            generateWindows() {
                const windows = [];
                const rows = Math.floor(this.height / 40);
                const cols = Math.floor(this.width / 40);

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        windows.push({
                            x: col * 40 + 10,
                            y: row * 40 + 10,
                            lit: Math.random() < 0.7,
                            flickerTimer: Math.random() * 1000
                        });
                    }
                }
                return windows;
            }

            update(gameSpeed, canvasWidth, canvasHeight) {
                this.x -= gameSpeed / 2;
                if (this.x + this.width < 0) {
                    this.x = canvasWidth;
                    this.width = Math.random() * 50 + 100;
                    this.height = Math.random() * 200 + 100;
                    this.y = canvasHeight - this.height;
                    this.windows = this.generateWindows();
                    this.color = this.randomBuildingColor();
                }
            }

            draw(ctx, dayNightCycle) {
                const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, this.getLighterShade(this.color));

                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                this.windows.forEach(window => {
                    window.flickerTimer += 1;
                    if (window.flickerTimer > 1000) {
                        window.flickerTimer = 0;
                        window.lit = Math.random() < 0.7;
                    }

                    ctx.fillStyle = window.lit ? `rgba(255, 255, 0, ${0.7 * (1 - dayNightCycle)})` : 'rgba(100, 100, 100, 0.5)';
                    ctx.fillRect(this.x + window.x, this.y + window.y, 20, 20);
                });
            }

            getLighterShade(color) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                
                const lighterR = Math.min(r + 20, 255).toString(16).padStart(2, '0');
                const lighterG = Math.min(g + 20, 255).toString(16).padStart(2, '0');
                const lighterB = Math.min(b + 20, 255).toString(16).padStart(2, '0');
                
                return `#${lighterR}${lighterG}${lighterB}`;
            }
        }

        class Sky {
            constructor(canvas) {
                this.canvas = canvas;
                this.stars = this.generateStars();
                this.timeOfDay = 0; // 0 to 1, representing a full day-night cycle
                this.moonPhase = Math.random();
                this.clouds = this.generateClouds();
            }

            generateStars() {
                const stars = [];
                for (let i = 0; i < 200; i++) {
                    stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height / 2,
                        size: Math.random() * 1.5 + 0.5,
                        blinkSpeed: Math.random() * 0.05 + 0.01
                    });
                }
                return stars;
            }

            generateClouds() {
                const clouds = [];
                for (let i = 0; i < 7; i++) {
                    clouds.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * (this.canvas.height / 3),
                        speed: (Math.random() - 0.5) * 1 + 0.3,
                        segments: Math.floor(Math.random() * 3) + 3,
                        circles: this.generateCloudCircles()
                    });
                }
                return clouds;
            }

            generateCloudCircles() {
                const circles = [];
                const baseRadius = Math.random() * 20 + 30;
                const circleCount = Math.floor(Math.random() * 3) + 3;

                for (let i = 0; i < circleCount; i++) {
                    circles.push({
                        x: i * baseRadius * 0.7,
                        y: (Math.random() - 0.5) * baseRadius * 0.5,
                        radius: baseRadius * (0.7 + Math.random() * 0.3)
                    });
                }
                return circles;
            }

            update(gameSpeed) {
                this.timeOfDay = (this.timeOfDay + 0.0001 * gameSpeed) % 1;
                this.moonPhase = (this.moonPhase + 0.00001 * gameSpeed) % 1;

                this.stars.forEach(star => {
                    star.blink = Math.sin(Date.now() * star.blinkSpeed) * 0.5 + 0.5;
                });

                this.clouds.forEach(cloud => {
                    cloud.x += cloud.speed;
                    if (cloud.x > this.canvas.width + 200) {
                        cloud.x = -200;
                        cloud.y = Math.random() * (this.canvas.height / 3);
                        cloud.circles = this.generateCloudCircles();
                    }
                });
            }

            draw(ctx) {
                this.drawSky(ctx);
                this.drawStars(ctx);
                this.drawSun(ctx);
                this.drawMoon(ctx);
                this.drawClouds(ctx);
            }

            drawSky(ctx) {
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                
                if (this.timeOfDay < 0.25) { // Night to sunrise
                    const t = this.timeOfDay / 0.25;
                    gradient.addColorStop(0, this.lerpColor('#000033', '#87CEEB', t));
                    gradient.addColorStop(1, this.lerpColor('#000000', '#FF6600', t));
                } else if (this.timeOfDay < 0.5) { // Sunrise to noon
                    const t = (this.timeOfDay - 0.25) / 0.25;
                    gradient.addColorStop(0, this.lerpColor('#87CEEB', '#4A90E2', t));
                    gradient.addColorStop(1, this.lerpColor('#FF6600', '#FFFFFF', t));
                } else if (this.timeOfDay < 0.75) { // Noon to sunset
                    const t = (this.timeOfDay - 0.5) / 0.25;
                    gradient.addColorStop(0, this.lerpColor('#4A90E2', '#87CEEB', t));
                    gradient.addColorStop(1, this.lerpColor('#FFFFFF', '#FF6600', t));
                } else { // Sunset to night
                    const t = (this.timeOfDay - 0.75) / 0.25;
                    gradient.addColorStop(0, this.lerpColor('#87CEEB', '#000033', t));
                    gradient.addColorStop(1, this.lerpColor('#FF6600', '#000000', t));
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawStars(ctx) {
                const starVisibility = Math.max(0, Math.min(1, 1 - Math.sin(this.timeOfDay * Math.PI)));
                
                if (starVisibility > 0) {
                    this.stars.forEach(star => {
                        const opacity = star.blink * starVisibility;
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            }

            drawSun(ctx) {
                const angle = (this.timeOfDay + 0.5) % 1 * Math.PI * 2 - Math.PI / 2;
                const radius = this.canvas.height * 0.8;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height;
                
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                // Only draw sun when it's above the horizon
                if (y < this.canvas.height) {
                    // Outer glow
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, 40);
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
                    gradient.addColorStop(0.2, 'rgba(255, 255, 0, 1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, 40, 0, Math.PI * 2);
                    ctx.fill();

                    // Sharp inner sun
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            drawMoon(ctx) {
                const angle = this.timeOfDay * Math.PI * 2 - Math.PI / 2;
                const radius = this.canvas.height * 0.8;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height;
                
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                // Only draw moon when it's above the horizon
                if (y < this.canvas.height) {
                    // Moon glow
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, 40);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, 40, 0, Math.PI * 2);
                    ctx.fill();

                    // Moon surface
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI * 2);
                    ctx.fill();

                    // // Moon phase
                    // ctx.fillStyle = 'rgba(0, 0, 51, 0.8)';
                    // ctx.beginPath();
                    // ctx.arc(x, y, 20, -Math.PI/2, Math.PI/2);
                    // const phaseAngle = this.moonPhase * Math.PI * 2;
                    // if (this.moonPhase < 0.5) {
                    //     ctx.arc(x + 20 * Math.cos(phaseAngle), y, 20 * Math.sin(phaseAngle), Math.PI/2, -Math.PI/2, true);
                    // } else {
                    //     ctx.arc(x + 20 * Math.cos(phaseAngle), y, 20 * Math.sin(phaseAngle), -Math.PI/2, Math.PI/2);
                    // }
                    // ctx.fill();

                    // // Craters
                    this.drawCrater(ctx, x - 8, y - 5, 5);
                    this.drawCrater(ctx, x + 5, y + 7, 4);
                    this.drawCrater(ctx, x - 5, y + 10, 3);
                }
            }

            drawCrater(ctx, x, y, radius) {
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(180, 180, 180, 1)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            drawClouds(ctx) {
                this.clouds.forEach(cloud => {
                    ctx.save();
                    ctx.translate(cloud.x, cloud.y);

                    const gradient = ctx.createLinearGradient(0, 0, 0, 60);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');
                    ctx.fillStyle = gradient;

                    ctx.beginPath();
                    cloud.circles.forEach(circle => {
                        ctx.moveTo(circle.x + circle.radius, circle.y);
                        ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                    });
                    ctx.fill();

                    ctx.restore();
                });
            }

            lerpColor(color1, color2, t) {
                const r1 = parseInt(color1.substr(1, 2), 16);
                const g1 = parseInt(color1.substr(3, 2), 16);
                const b1 = parseInt(color1.substr(5, 2), 16);
                
                const r2 = parseInt(color2.substr(1, 2), 16);
                const g2 = parseInt(color2.substr(3, 2), 16);
                const b2 = parseInt(color2.substr(5, 2), 16);
                
                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);
                
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.speedX = Math.random() * 3 - 1.5;
                this.speedY = Math.random() * 3 - 1.5;
                this.color = `hsl(${Math.random() * 60 + 180}, 100%, 50%)`;
                this.lifespan = 100;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.size *= 0.95;
                this.lifespan--;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const canvas = document.getElementById('gameCanvas');
        const game = new Game(canvas);
        
        function gameLoop() {
            game.update();
            game.draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();

        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                if (game.state === GameState.START || game.state === GameState.GAME_OVER) {
                    game.startGame();
                } else if (game.state === GameState.PLAYING) {
                    game.runner.jump();
                    game.sounds.jump.play();
                }
            } else if (event.code === 'ArrowDown') {
                game.runner.duck();
            } else if (event.code === 'KeyP') {
                game.pauseGame();
            }
        });

        document.addEventListener('keyup', (event) => {
            if (event.code === 'ArrowDown') {
                game.runner.stand();
            }
        });
    </script>
</body>
</html>